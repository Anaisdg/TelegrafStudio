import { TelegrafConfig, PluginType } from '@shared/schema';

/**
 * Converts a TelegrafConfig object to TOML format
 */
export function convertConfigToToml(config: TelegrafConfig): string {
  let toml = `# Telegraf Configuration
# Generated by prototypeTelegrafConfigurator

[agent]
`;

  // Add agent settings
  Object.entries(config.agent).forEach(([key, value]) => {
    if (typeof value === 'string') {
      toml += `  ${key} = "${value}"\n`;
    } else {
      toml += `  ${key} = ${value}\n`;
    }
  });

  // Add secret stores
  if (config.secretStores && config.secretStores.length > 0) {
    toml += '\n';
    config.secretStores.forEach(store => {
      toml += `[[secretstores.${store.type}]]\n`;
      toml += `  # Using OS secret store\n`;
    });
  }

  // Group nodes by plugin type
  const nodesByType: Record<string, any[]> = {};
  config.nodes.forEach(node => {
    if (!nodesByType[node.type]) {
      nodesByType[node.type] = [];
    }
    nodesByType[node.type].push(node);
  });

  // Process nodes in order: input, processor, aggregator, serializer, output
  const typeOrder = [
    PluginType.INPUT,
    PluginType.PROCESSOR,
    PluginType.AGGREGATOR,
    PluginType.SERIALIZER, 
    PluginType.OUTPUT
  ];

  typeOrder.forEach(type => {
    if (nodesByType[type]) {
      nodesByType[type].forEach(node => {
        toml += '\n';
        toml += `[[${type}s.${node.plugin}]]\n`;
        
        // Add filters from connections where this node is the target
        const connections = config.connections.filter(conn => conn.source === node.id);
        if (connections.length > 0) {
          // Extract all filters
          connections.forEach(conn => {
            if (conn.filters) {
              Object.entries(conn.filters).forEach(([filterType, values]) => {
                if (values.length > 0) {
                  toml += `  ${filterType} = ${JSON.stringify(values)}\n`;
                }
              });
            }
          });
        }
        
        // Add node data
        if (node.data) {
          Object.entries(node.data).forEach(([key, value]) => {
            if (typeof value === 'object' && value !== null) {
              // Handle nested objects like fields in converter
              toml += `  [${type}s.${node.plugin}.${key}]\n`;
              Object.entries(value).forEach(([subKey, subValue]) => {
                toml += `    ${subKey} = ${JSON.stringify(subValue)}\n`;
              });
            } else if (Array.isArray(value)) {
              toml += `  ${key} = ${JSON.stringify(value)}\n`;
            } else if (typeof value === 'string') {
              toml += `  ${key} = "${value}"\n`;
            } else if (value !== undefined) {
              toml += `  ${key} = ${value}\n`;
            }
          });
        } else {
          toml += `  # No specific configuration\n`;
        }
      });
    }
  });

  return toml;
}

/**
 * Helper function to create default node data based on plugin type
 */
export function getDefaultNodeData(plugin: string): any {
  switch (plugin) {
    case 'cpu':
      return {
        percpu: true,
        totalcpu: true,
        collect_cpu_time: false,
        report_active: false,
      };
    case 'mem':
      return {};
    case 'converter':
      return {
        fields: {
          integer: ['usage_*'],
        },
      };
    case 'influxdb_v2':
      return {
        urls: ['http://localhost:8086'],
        token: '@{mystore:influx_token}',
        organization: 'my-org',
        bucket: 'telegraf',
      };
    case 'file':
      return {
        files: ['stdout', '/tmp/metrics.out'],
        rotation_interval: '1d',
        data_format: 'influx',
      };
    default:
      return {};
  }
}
