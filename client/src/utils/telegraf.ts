import { TelegrafConfig, PluginType } from '@shared/schema';
import { PluginConfig } from './pluginParser';

/**
 * Converts a TelegrafConfig object to TOML format
 */
export function convertConfigToToml(config: TelegrafConfig): string {
  let toml = `# Telegraf Configuration
# Generated by prototypeTelegrafConfigurator

[agent]
`;

  // Add agent settings
  Object.entries(config.agent).forEach(([key, value]) => {
    if (typeof value === 'string') {
      toml += `  ${key} = "${value}"\n`;
    } else {
      toml += `  ${key} = ${value}\n`;
    }
  });

  // Add secret store
  if (config.secretStore) {
    toml += '\n# Secret Store Configuration\n';
    toml += `[[secretstores.${config.secretStore.plugin}]]\n`;
    
    // Add secret store config
    if (config.secretStore.config) {
      Object.entries(config.secretStore.config).forEach(([key, value]) => {
        if (typeof value === 'string') {
          toml += `  ${key} = "${value}"\n`;
        } else if (value !== undefined && value !== null) {
          toml += `  ${key} = ${value}\n`;
        }
      });
    }
    
    // Add secrets if they exist (commented as sensitive information)
    if (config.secretStore.secrets && Object.keys(config.secretStore.secrets).length > 0) {
      toml += '\n  # Secrets (managed by secret store)\n';
      toml += '  # The following secrets are available for reference using @{store_id:secret_key} syntax:\n';
      Object.keys(config.secretStore.secrets).forEach(key => {
        toml += `  # - ${key}\n`;
      });
    }
  }

  // Group nodes by plugin type
  const nodesByType: Record<string, any[]> = {};
  config.nodes.forEach(node => {
    if (!nodesByType[node.type]) {
      nodesByType[node.type] = [];
    }
    nodesByType[node.type].push(node);
  });

  // Process nodes in order: input, processor, aggregator, serializer, output
  const typeOrder = [
    PluginType.INPUT,
    PluginType.PROCESSOR,
    PluginType.AGGREGATOR,
    PluginType.SERIALIZER, 
    PluginType.OUTPUT
  ];

  typeOrder.forEach(type => {
    if (nodesByType[type]) {
      nodesByType[type].forEach(node => {
        toml += '\n';
        toml += `[[${type}s.${node.plugin}]]\n`;
        
        // Add node data
        // Add filters from connections targeting this node (legacy approach - will be phased out)
        const incomingConnections = config.connections.filter(conn => conn.target === node.id);
        if (incomingConnections.length > 0) {
          // Extract all filters from legacy connections
          incomingConnections.forEach(conn => {
            if (conn.filters) {
              Object.entries(conn.filters).forEach(([filterType, values]) => {
                if (values.length > 0) {
                  toml += `  ${filterType} = ${JSON.stringify(values)}\n`;
                }
              });
            }
          });
        }
        
        if (node.data) {
          // Process the data fields
          Object.entries(node.data).forEach(([key, value]) => {
            // Special handling for filters
            if (['namepass', 'namedrop', 'fieldpass', 'fielddrop'].includes(key) && Array.isArray(value)) {
              toml += `  ${key} = ${JSON.stringify(value)}\n`;
              return;
            }
            
            // Special handling for tagpass and tagdrop (objects)
            if (['tagpass', 'tagdrop'].includes(key) && typeof value === 'object' && value !== null && !Array.isArray(value)) {
              toml += `  [${type}s.${node.plugin}.${key}]\n`;
              
              // Safely cast value to Record with a non-null assertion since we've checked for null
              const tagObject = value as Record<string, string[]>;
              Object.entries(tagObject).forEach(([tagKey, tagValue]) => {
                toml += `    ${tagKey} = ${JSON.stringify(tagValue)}\n`;
              });
              return;
            }
            
            // General object handling (like converter fields)
            if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
              toml += `  [${type}s.${node.plugin}.${key}]\n`;
              
              // Safely cast value to Record
              const objValue = value as Record<string, any>;
              Object.entries(objValue).forEach(([subKey, subValue]) => {
                toml += `    ${subKey} = ${JSON.stringify(subValue)}\n`;
              });
            } else if (Array.isArray(value)) {
              // Properly format arrays 
              toml += `  ${key} = ${JSON.stringify(value)}\n`;
            } else if (typeof value === 'string') {
              toml += `  ${key} = "${value}"\n`;
            } else if (value !== undefined) {
              toml += `  ${key} = ${value}\n`;
            }
          });
        } else {
          toml += `  # No specific configuration\n`;
        }
      });
    }
  });

  return toml;
}

/**
 * Helper function to create default node data based on plugin type
 */
export function getDefaultNodeData(plugin: string): any {
  switch (plugin) {
    case 'cpu':
      return {
        percpu: true,
        totalcpu: true,
        collect_cpu_time: false,
        report_active: false,
      };
    case 'mem':
      return {};
    case 'converter':
      return {
        fields: {
          integer: ['usage_*'],
        },
      };
    case 'influxdb_v2':
      return {
        urls: ['http://localhost:8086'],
        token: '@{mystore:influx_token}',
        organization: 'my-org',
        bucket: 'telegraf',
      };
    case 'file':
      return {
        files: ['stdout', '/tmp/metrics.out'],
        rotation_interval: '1d',
        data_format: 'influx',
      };
    default:
      return {};
  }
}

/**
 * Returns a pre-defined plugin configuration for a given plugin and type
 * In a production app, these would be fetched from GitHub or a plugin registry
 */
export function getDefaultPluginConfig(plugin: string, type: string): PluginConfig | null {
  if (plugin === 'influxdb_v2' && type === 'output') {
    return {
      name: 'influxdb_v2',
      displayName: 'InfluxDB v2',
      type: 'output',
      description: 'Configuration for sending metrics to InfluxDB 2.0',
      fields: [
        {
          name: 'urls',
          type: 'array',
          required: true,
          sensitive: false,
          default: ['http://127.0.0.1:8086'],
          description: 'The URLs of the InfluxDB cluster nodes. Multiple URLs can be specified for a single cluster, only ONE of the urls will be written to each interval.'
        },
        {
          name: 'token',
          type: 'string',
          required: true,
          sensitive: true,
          default: '',
          description: 'Token for authentication.'
        },
        {
          name: 'organization',
          type: 'string',
          required: true,
          sensitive: false,
          default: '',
          description: 'Organization is the name of the organization you wish to write to.'
        },
        {
          name: 'bucket',
          type: 'string',
          required: true,
          sensitive: false,
          default: '',
          description: 'Destination bucket to write into.'
        }
      ]
    };
  } else if (plugin === 'cpu' && type === 'input') {
    return {
      name: 'cpu',
      displayName: 'CPU',
      type: 'input',
      description: 'Read metrics about cpu usage',
      fields: [
        {
          name: 'percpu',
          type: 'boolean',
          required: false,
          sensitive: false,
          default: true,
          description: 'Whether to report per-cpu metrics'
        },
        {
          name: 'totalcpu',
          type: 'boolean',
          required: false,
          sensitive: false,
          default: true,
          description: 'Whether to report total system cpu metrics'
        },
        {
          name: 'collect_cpu_time',
          type: 'boolean',
          required: false,
          sensitive: false,
          default: false,
          description: 'If true, collect raw CPU time metrics'
        },
        {
          name: 'report_active',
          type: 'boolean',
          required: false,
          sensitive: false,
          default: false,
          description: 'If true, report sum of all non-idle CPU states'
        }
      ]
    };
  } else if (plugin === 'mem' && type === 'input') {
    return {
      name: 'mem',
      displayName: 'Memory',
      type: 'input',
      description: 'Read metrics about system memory usage',
      fields: []
    };
  } else if (plugin === 'file' && type === 'output') {
    return {
      name: 'file',
      displayName: 'File',
      type: 'output',
      description: 'Send telegraf metrics to file(s)',
      fields: [
        {
          name: 'files',
          type: 'array',
          required: true,
          sensitive: false,
          default: ['stdout'],
          description: 'Files to write to, "stdout" is a specially handled file'
        },
        {
          name: 'rotation_interval',
          type: 'string',
          required: false,
          sensitive: false,
          default: '0d',
          description: 'Duration after which a new file is created'
        },
        {
          name: 'data_format',
          type: 'string',
          required: false,
          sensitive: false,
          default: 'influx',
          description: 'Data format to output'
        }
      ]
    };
  }
  
  return null;
}
